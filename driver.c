/* 
 * Group 05
 * Kush Mehta			2018B5A70956P
 * Purusharth Amrut		2018B5A70897P
 * Patel Darsh Rajesh		2018B4A70532P
 * Harsh Jhunjhunwala		2018B5A70691P
 * Jatin Aggarwal		2018B4A70884P
 */

/*
 * driver.c: contains the main function
 * provides an interface for testing the lexer and parser modules
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "lexer.h"
#include "parser.h"
#include "parserDef.h"
#include "utils.h"


int main(int argc, char *argv[]) 
{
    FILE *sourceFile,*parsetreeOutfile, *dstFile;
    int choice;
    tokenInfo currentToken;
    unsigned long long lineNum;
    Grammar g;
    g = malloc(sizeof(lhsChar) * NO_OF_NONTERMINALS);
    getGram("grammar.txt", g);
    
	//     FirstSet firstSet=(FirstSet)malloc(NO_OF_NONTERMINALS*sizeof(first));
	//     FollowSet followSet=(FollowSet)malloc(NO_OF_NONTERMINALS*sizeof(first));
	//     buildFirstSet(g,firstnfollow->first);
	//     getFollowSets(g, firstnfollow->follow,firstnfollow->first);
	for (int nt=0; nt<NO_OF_NONTERMINALS; nt++) {
		computeFirst(g, nt);
	}
	for (int nt=0; nt<NO_OF_NONTERMINALS; nt++) {
		if (g[nt].isNullable)
			computeFollow(g, nt);
	}
    
    int t[NO_OF_NONTERMINALS][NO_OF_TERMINALS];
    parseTree root=malloc(sizeof(parsetree));
    int error = 0;
    createParseTable(g,t);
    
    clock_t    start_time, end_time;
    double total_CPU_time = 0, total_CPU_time_in_seconds = 0;

	int ans = 0,m1=0,m2=0,nodes,m3=0,m4=0;
					
    if(argc != 3) 
    {
        fprintf(stderr, "error: incorrect number of arguments\n");
        return 1;
    }
        
    
    while(true) 
    {
		printf("\n0.EXIT");
        printf("\n1.Removal of Comments");
        printf("\n2. Print the tokens list generated by lexer (on Console)");
        printf("\n3. Print parse tree and output errors if any (on Console)");
        // printf("\n3. Print Abstract Syntax Tree and Order of Traversal (on Console)");
        // printf("\n4. Display the amount of allocated memory and no. of nodes to each of parse tree and abstract syntax tree.");
        // printf("\n5. Print the Symbol Table");
        // printf("\n6. Print the list of global variables, their types and offsets");
        // printf("\n7. Print the total memory requirement for each function");
        // printf("\n8. Print the type expressions and width of globally visible record definitions");
        // printf("\n9. Verify the syntactic and semantic correctness and Print total time taken by compiler (on Console)");
        // printf("\n10. For producing assembly code");


        
        
        printf("\n\nEnter your choice: ");
        scanf("%d", &choice);
        printf("\n");

        switch(choice) 
        {
        	//0.EXIT
		    case 0:
		     		return 0;
		     
			//1. Print the tokens list generated by lexer (on Console)
		    case 1:
		    		printf("\n\n------------------------------------------------------------------\n\n");
				    sourceFile = fopen(argv[1], "r");
				    dstFile = fopen(argv[2], "w");
				    removeComments(argv[1], argv[2]);
		    case 2:
					printf("\n\n------------------------------------------------------------------\n\n");
					sourceFile = fopen(argv[1], "r");
					fseek(sourceFile,0,SEEK_SET);
					if(sourceFile == NULL) 
					{
					fprintf(stderr, "error: %s: cannot open file\n", argv[1]);
					return 1;
					}
					printTokenizedCode(sourceFile);
					fclose(sourceFile);
					printf("\n\n------------------------------------------------------------------\n\n");
					
		            break;
		            
		  	//2. Print parse tree and output errors if any (on Console)
		    case 3:
		    		printf("\n\n------------------------------------------------------------------\n\n");
		     		sourceFile = fopen(argv[1], "r");
		    			fseek(sourceFile,0,SEEK_SET);
					    if(sourceFile == NULL) 
					    {
							fprintf(stderr, "error: %s: cannot open file\n", argv[1]);
							return 1;
						}
		     		start_time = clock();		     			
					int error=0;					
					parseInputSourceCode(sourceFile,t,g,root,&error);
					parseTree tree = malloc(sizeof(parsetree));
					printParseTree(tree);
					end_time = clock();
					if(!m1)
					{ 
						total_CPU_time +=  (double) (end_time - start_time);
                		total_CPU_time_in_seconds +=  total_CPU_time / CLOCKS_PER_SEC;
						ans++; 
					}					
					break;		       
		     default:
		     		// invalid option
		            fprintf(stderr, "\nstage2: error: invalid option\n");
        }
    }

    return 0;
}
